\chapter{Zusammenfassung der Algorithmen}

\section{Einleitung}

\section{Paging}
\begin{tabularx}{\textwidth}{|l|X|X|X|} \hline
Kurzform & Name & Beschreibung & Kosten\\ \hline \hline
LRU  & least-recently-used      & & strikt $k$-kompetitiv (Markierungsalgo) \\ \hline
FWF  & flush-when-full          & & strikt $k$-kompetitiv (Markierungsalgo) \\ \hline
FIFO & first-in-first-out       & & $k$-kompetitiv (kein Markierungsalgo) \\ \hline
LFU  & least-frequently-used    & & nicht kompetitiv\\ \hline
LIFO & last-in-first-out        & & nicht kompetitiv\\ \hline
LFD  & longest-forward-distance & & optimaler Offline-Algorithmus \\ \hline
RANDOM & RANDOM & Verdrängt uniform zufällig gewählte Seite aus dem Cache & $k$-kompetitiv\\ \hline
MARK & MARK & Verdrängt eine uniform zufällig gewählte Seite, die in der aktuellen Phase noch nicht vorgekommen ist & $2H_k$-kompetitiv \\ \hline
\end{tabularx}


\section{k-Server-Problem}
\begin{tabularx}{\textwidth}{|l|X|X|X|} \hline
Kurzform & Name & Beschreibung & Laufzeit\\ \hline \hline
Greedy  & Greedy & Bewege immer den nächstgelegenen Server zur Anfrage & beliebig schlecht \\ \hline
DC  & Double Coverage & gilt auf der Linie und auf Bäumen! Liegt die Anfrage links oder rechts von allen Servern, so bewege den nächsten Server zur Anfrage; liegt Anfrage zwischen zwei Servern, bewege beide \"gleich schnell\" zur Anfrage, bis einer ankommt& l-kompetitiv auf der Linie \\ \hline
 $SC_{\gamma}$ & $Slack Coverage_{\gamma}$ & ähnlich wie DC, nur im euklidischem Raum: der nähere Server x wird auf die Anfrage gezogen, der andere wird um $\gamma \cdot slack(x, y, r)$ Richtung alter Position x geschoben (slack(x, y, r) = d(x, y) + d(x, r) - d(y, r)) & für $\gamma = \tfrac{1}{2}$ ist SC 3-kopetitiv \\ \hline
\end{tabularx}


\section{Approximation von Metriken}
\begin{tabularx}{\textwidth}{|l|l|X|l|} \hline
Kurzform & Name & Beschreibung & Laufzeit\\ \hline \hline
 HierPart($\mathcal{M} = (V, d)$) &  & berechnet eine hierarch. Partition mit Hilfe von Partition &  \\ \hline
 Partition &  & zerlegt gegebenenfalls jeder (con HierPart übergebene Klasse in mehrere Klassen (mit dem neuen Radius )&  \\ \hline
\end{tabularx}


\section{Online-Probleme beim Handel}
\subsection{Online-Suche und One-Way-Trading}
\begin{tabularx}{\textwidth}{|l|l|X|X|} \hline
Kurzform & Name & Beschreibung & Kosten\\ \hline \hline
RPA($z$) & Reservationspreisalgo & Akzeptiert den ersten Wechselkurs $\geq z$ (Online-Suche) & $\sqrt{\varphi}$-kompetitiv mit $z=\sqrt{Mm}$ \\ \hline
EXPO & EXPO & Sei $\varphi = \frac{M}{m} = 2^k$. Wählt $i$ uniform zufällig aus $\{0,...,k-1\}$ und wendet $\textrm{RPA}(m2^i)$ an & strikt $(c(\varphi)\log\varphi)$-kompetitiv mit $c(\varphi) \leq 2 \xrightarrow{\varphi \rightarrow \infty} 1$ \\ \hline
$\textrm{EXPO}_q$ & $\textrm{EXPO}_q$ & Sei $\varphi = \frac{M}{m} = 2^k$. Wählt $i$ zufällig nach $q$ aus $\{0,...,k-1\}$ und wendet $\textrm{RPA}(p_1\cdot2^i)$ an. Benötigt im Gegensatz zu EXPO keine Kenntniss über $[m,M]$ oder $\varphi$ & strikt $\frac{2}{q(\lfloor\log\varphi\rfloor)}$-kompetitiv \\ \hline
Threat($r$) & Drohungsalgorithmus & Tauscht immer genau so viel, dass er bis zum aktuellen Schritt $r$-komopetitiv ist, sonst Fehler & strikt $r$-kompetitiv (falls kein Fehler) \\ \hline
\end{tabularx}

\subsection{Economical Caching}
\begin{tabularx}{\textwidth}{|l|l|X|X|} \hline
Kurzform & Name & Beschreibung & Kosten\\ \hline \hline
RPA($\sqrt{\varphi}$) & Reservationspreisalgo & Kauft bei einem Preis unter $\sqrt{\varphi}$ so viel wie möglich, sonst so wenig wie möglich & $\sqrt{\varphi}$-kompetitiv \\ \hline
\end{tabularx}


\section{Scheduling}
\begin{tabularx}{\textwidth}{|l|X|X|} \hline
Name & Beschreibung & Laufzeit\\ \hline \hline
Least-Loaded & Ordnet einen neuen Job der Maschine mit der kleinsten Ausführungszeit zu & strikt $(2-1/m)$-kompetitiv mit $m =$ Anzahl der Maschinen\\ \hline
Longest-Processing-Time (Offline!) & Sortiere Jobs absteigend nach ihrer Dauer, dann Least-Loaded & $4/3$-Approximationsalgorithmus\\ \hline
Slow-Fit($\alpha$) & Ordne einen neuen Job der langsamsten Maschine zu, die nach der Zuordnung noch eine Ausführungszeit $\leq 2\alpha$ hat & $2\alpha$-kompetitiv, keine Fehlermeldung für $\alpha \geq \textrm{OPT}(\sigma)$, \textbf{Problem:} $\textrm{OPT}(\sigma)$ ist nicht bekannt \\ \hline
Slow-Fit($\alpha_k$) & Ordne einen neuen Job der langsamsten Maschine zu, die nach der Zuordnung noch eine Ausführungszeit $\leq 2\alpha$ hat, ansontent verdoppele $\alpha$ & strikt 8-kompetitiv \\ \hline
\end{tabularx}

\section{Das Online-Matching-Problem}
\begin{tabularx}{\textwidth}{|l|l|X|X|} \hline
Kurzform & Name & Beschreibung & Laufzeit\\ \hline \hline
GREEDY & GREEDY & Matched einen neuen Knoten mit einem beliebigen (nicht zufälligen) adjazenten Knoten aus $V$ & 2-kompetitiv \\ \hline
RANDOM & RANDOM & Matched einen neuen Knoten mit einem zufällig ausgewählten adjazenten Knoten aus $V$ & 2-kompetitiv \\ \hline
RANKING & RANKING & Wählt eine zufällige Permutation der Knotenmenge $V$ und matched dann zu dem ersten adjazenten Knoten $v_i$ in der Permutation & etwa strikt 1,58-kompetitiv \\ \hline
\end{tabularx}
