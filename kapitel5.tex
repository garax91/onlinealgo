\chapter{Online-Probleme beim Handel}


\section{Online-Suche und One-Way-Trading}

\subsection{Zusammenhang der beiden Problemvarianten}

\textbf{Theorem 5.1.} a) Zu jedem randomisierten Algorithmus $A_{R}$ für One-Way-Trading existiert ein deterministischer Algorithmus $A_{D}$ für One-Way-Trading, sodass $p_{A_{D}}(\sigma) = E[p_{A_{R}}(\sigma)]$ für alle Eingaben $\sigma$ gilt. \\
b) Für jeden deterministischen Algorithmus $A_{D}$ für One-Way-Trading existiert ein randomisierter Algorithmus $A_{R}$ für Online-Suche, sodass $p_{A_{D}}(\sigma) = E[p_{A_{R}}(\sigma)]$ für alle Eingaben $\sigma$ gilt.

\textit{Beweis:} a) Sei beliebige Eingabe $\sigma = (p_{1}, ..., p_{n})$ gegeben. Außerdem sei $A_{R}$ ein bel. randomisierter Algo. Algo $A_{D}$ tauscht im i-ten Schritt genau so viel, wie $A_{R}$ im Erwartungswert ($E[X_{i}]$). Dies ist möglich, da sowohl $E[X_{i}]$ als auch die Summe aller Erwartungswerte zwischen 0 und 1 liegen muss (da sonst der Algorithmus $A_{R}$ ungültig wäre). \\
b) Sei $A_{D}$ bel. deterministischer Algo für One-Way-Trading. $x_{i}$ ist der Betrag, den $A_{D}$ im i-ten Schritt tauscht. Der randomisierte Algorithmus $A_{R}$ akzeptiert den i-ten Wechselkurs mit Wahrscheinlichkeit $x_{i}$. (Dieser Algo ist erlaubt, da die Summe aller $x_{i} \le 1$ ist.)

\subsection{Algorithmen für Online-Suche}

Das Intervall [m, M] beinhaltet alle möglichen Wechselkurse.\\
$\varphi = \tfrac{M}{m}$\\
\\
\textit{Reservationspreisalgorithmus (RPA(z)):} Akzeptiert den ersten Wechselkurs $\ge$ z. Gibt es keinen, muss er am Ende zum Wechselkurs m tauschen.  

\textbf{Theorem 5.2.} Der Algorithmus RPA(p*) mit $p* = \sqrt{Mm}$ ist strikt $\sqrt{\varphi}$ - kompetitiv.

\textit{Beweis:} Sei $\sigma = (p_{1}, ..., p_{n})$ bel. Eingabe. Es gilt OPT $(\sigma) = p_{max}$. \\
1.Fall: Ist $p_{max} < p*$, so ist $p_{RPA(p*}(\sigma) = m$ (hat keinen Kurs akzeptiert). Also gilt: $\tfrac{OPT(\sigma)}{p_{RPA(p*)(\sigma)}} < \tfrac{p*}{m} = \sqrt{\varphi}$.\\
2.Fall: Ist $p_{max} \ge p*$ so ist $p_{RPA(p*}(\sigma) \ge p*$ (hat ersten Wechselkurs $\ge$ p* akzeptiert). Also gilt: $\tfrac{OPT(\sigma)}{p_{RPA(p*)(\sigma)}} \le \tfrac{M}{p*} = \sqrt{\varphi}$.

\textit{EXPO (randomisiert):} Sei $\varphi = M / m = 2^k$. EXPO wählt i uniform zufällig aus der Menge {0, ..., k - 1} aus und wendet den deterministischen Algo RP$A(m2^{i})$ an.

\textbf{Theorem 5.3.} Der Algorithmus EXPO ist strikt $(c(\varphi)log\varphi)$-kompetitiv. Dabei ist c eine Funktion, ddie für große $\varphi$ gegen 1 konvergiert und für die $c(\varphi) \le 2$ für alle $\varphi = 2^k$ gilt.

\textit{Beweis:} !!!!!TODO!!!!!

\textbf{Theorem 5.4.} Der Algorithmus $EXPO_{q}$ ist strikt $\tfrac{2}{q\lfloor log\varphi \rfloor)}$-kompetitiv.

\textit{Beweis:} !!!!!TODO!!!!!

\subsection{Optimaler Onlin-Algorithmus für One-Way-Trading}

\textit{Drohungs-Algorithmus (Threat):} Threat bekommt einen Wert $r \ge 1$ übergeben und versucht, einen strikt kompetitiven Faktor r zu erreichen. Sei $\sigma = (p_{1}, ..., p_{n})$ die Eingabe. Dann verhält sich Threat(r) wie folgt:\\
1. Falls $p_{i} < max_{1 \le j < i}p_{j}$ (bisher bester Kurs), so tauscht der Algorithmus nichts.\\
2. Ansonsten: Threat(r) tauscht den kleinstmöglichen Betrag zum Kurs $p_{i}$, dass er auf der bisherigen Eingabe strikt r-kompetitiv ist (falls die Eingabe zu Ende sein sollte, Threat müsste dann den Rest zum Kurs von m kaufen). Gibt es keinen solchen Betrag, so gibt Threat(r) eine Fehlermeldung zurück.

\textbf{Theorem 5.5.} Gibt es einen strikt r-kompetitiven Algorithmus für One-Way-Trading, so ist auch der Algorithmus Threat(r) strikt r-kompetitiv. Insbesondere gibt Threat(r) dann auf keiner Eingabe eine Fehlermeldung aus.

\textit{Beweis:} !!!!!TODO!!!!!

\textbf{Korollar 5.6.} Es sei $\sigma$ eine beliebige Eingabe der Länge n für One-Way-Trading. Gibt es einen Algorithmus, der auf der Eingabe $\sigma^{i}$ mit i $\in$ {1, ..., n} strikt r-kompetitiv ist, so ist auch der Algorithmus Threat(r) strikt r-kompetitiv auf $\sigma$ und gibt insbesondere keine Fehlermeldung auf dieser Eingabe aus.

\textbf{Korollar 5.7.} In dem Szenario, dass das Intervall [m, M] und die Eingabenlänge n bekannt sind, ist Threat($r_{n}^{*}$(m, M)) ein optimaler Online-Algorithmus.

\textit{Beweis:} !!!!!TODO!!!!!

\textbf{Korollar 5.8.} In dem Szenario, dass nur das Intervall [m, M] bekannt ist, ist der Algorithmus Threat($r_{\infty}^{*}$(m, M)) ein optimaler Online-Alforithmus. Er erreicht einen strikt kompetitiven Faktor von $\Theta(log \varphi)$. 

\section{Economical Caching}

Die Eingabe $\sigma = (\sigma_{1}, ..., \sigma_{n})$ beim Economical Caching besteht aus einem Preis $p_{i} \in [1, \varphi]$ und einem Verbrauch $v_{i} \ge 0$.\\
Der Lagerbestand ist definiert als: $L_{i}^{A} = L_{i-1}^{A} - v_{i} + x_{i}$ (neuer Lagerbestand = alter Lagerbestand - Verbrauch + Kauf).\\
$x_{i} \in [max{0, v_{i}-L_{i-1}^{A}}, 1-L_{i-1}^{A}+v_{i}]$ \\
Die Kosten von Algo A sind: $C_{A} = \sum_{i = 1}^{n} p_{i}x_{i}$

\subsection{Ein Reservationspreisalgorithmus}

Der Reservationspreisalgorithmus kauft bei einem Preis unter $\sqrt{\varphi}$ so viel wie möglich und bei einem Preis über $\sqrt{\varphi}$ so wenig wie möglich: \\
%$\lbrace{x_{i} = v_{i} + (1 - L_{i-1}^{RPA})  , falls  p_{i} \le \sqrt{\varphi}}   {max{0, v_{i} - L_{i-1}^{RPA}}  , falls  p_{i} > \sqrt{\varphi}}$


\textbf{Theorem 5.9.} Der Algorithmus RPA ist $\sqrt{\varphi}$-kompetitiv für das Economical-Caching-Problem

\textit{Beweis:} !!!!!TODO!!!!!

RPA kann nicht besser als $\sqrt{\varphi}$ werden: \\
$\sigma^{'} = \left(\begin{array}{c} \sqrt{\varphi} \\ 0 \end{array}\right), \left(\begin{array}{c} 1 \\ 0 \end{array}\right), \left(\begin{array}{c} \varphi \\ 1 \end{array}\right)$ \\
Diese Sequenz kann bel oft wiederholt werden, sodass die Kosten nicht in der Konstenten $\tau$ versteckt werden können

\subsection{Untere Schranken}

\textbf{Theorem 5.10.} Es gibt keinen deterministischen oder randomisierten Online-Algorithmus für das Economical-Chaching-Problem, der einen kompetitiven Faktor kleiner als $\tfrac{\sqrt{\varphi} +1}{2}$ erreicht.

\textit{Beweis:} !!!!!TODO!!!!!

\textit{lambertsche W-Funktion} ist die Umkehrfunktion von $f(x) = x \cdot e^{x}$

\textbf{Theorem 5.11.} Für alle $x \in [-\tfrac{1}{e}, 0)$ gilt ln(-W(x)) = ln(-x) - W(x)

\textit{Beweis:} Rechnung... (wahrscheinlich nicht relevant)

\textbf{Theorem 5.12.} Es gibt keinen deterministischen oder randomisierten Online-Algorithmus für das Economical-Caching-Problem, der einen kompetitiven Faktor kleiner als $r^{*}(\varphi) = \tfrac{1}{W(\tfrac{1-\varphi}{e\varphi})+1}$ erreicht

\textit{Beweis:} !!!!!TODO!!!!!

\subsection{Algorithmen mit fester Lagerfunktion}

\textit{Lagerfunktion} 

\textbf{Theorem 5.13.} Jeder Algorithmus $A_{f}$ mit einer festen Lagerfunktion f: [1, $\varphi$] $\to$ [0, 1] ist nicht besser als $\sqrt{\varphi}$-kompetitiv.

\textit{Beweis:} !!!!!TODO!!!!!

\subsection{Ein optimaler Online-Algorithmus}

\textit{Definiere Fuktion:} !!!!!TODO!!!!!
 
\textbf{Lemma 5.14.} Die Kosten eines optimalen Offline-Algorithmus auf der Eingabe $\sigma$ entwprechen der Summe $\sum_{i=1}^{n} C_{i}$.

\textit{Beweisidee:} Man müsste induktiv nachweisen, dass $A_{y}^{i} = (\sum_{j=18}^{i} C_{j} ) + \int_{0}^{\varphi} max{h_{i}(x) + y - 1, 0} dx $ für jedes i und jedes y $\in$ [0, 1] die Kosten eines optimalen Offline-Algorithmus angibt, der die Anfrage $\sigma_{1}, ... \sigma_{i}$ abarbeitet und danach den Lagerbestand y hat.

\textbf{Theorem 5.15.} Der Algorithmus Threat erreicht einen kompetitiven Faktor vonr $r^{*}$ für das Economical-Caching-Problem

\textit{Beweis:} Der Beweis wird nicht besprochen.